---
title: "PSTAT175 - Final Project - Part 1 - Recurrence"
author: "Zifeng(Robin) Zhan, Calder Glass, Kotaro Ito"
date: "2025-04-29"
output:
  pdf_document: default
  html_document: default
---

We used a significance level of $\alpha = 0.05$ as the critical value.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
library(survival)
library(survminer)
library(dplyr)
library(tidyverse)
data("colon")
View(colon)

sum(is.na(colon))

# There are 82 missing observations - accounts for 4.4% of the data, safe enough to remove those observations

colon = tibble(colon)

colon <- colon %>% 
  drop_na()

```

Two additional covariates will be introduced, start and stop, in order to build a counting process model later on.

Covariates that are either binaries or have very few levels, 3 to 4 maximum, are factored so that the effect of each level of the covariates can be summarized.
```{r}

# Factor some of the covariates first in order to do the cox ph tests:

colon <- colon %>% 
  mutate_at(c("sex", "obstruct", "perfor", "adhere", "differ", "etype", "node4", "surg", "extent"), factor)

# Preparing the split
colon$start = 0
colon$stop = colon$time
```

```{r}
# data for recurrence event
recurrence_data <- colon[colon$etype == 1, ]

# survival object
surv_object_recurrence <- Surv(time = recurrence_data$time, 
                               event = recurrence_data$status)

# Fit the Kaplan-Meier model for recurrence events
km_fit_recurrence <- survfit(surv_object_recurrence ~ 1)

# Plot the Kaplan-Meier survival curve for recurrence events with a title
ggsurvplot(km_fit_recurrence, 
           data = recurrence_data, 
           palette = "#00BFC4", # Customize the color
           title = "Kaplan-Meier Survival Curve for Recurrence Events")

```


Then we checked if the Cox Proportional Hazards assumption was violated or not in terms of the treatment covariate.

This is checked through a survival plot of the curves using the "cloglog" value for the fun parameter and a plot of the coxzph test.

If the p-value for the coxzph test for the treatment covariate is less than $0.05$, then the cox proportional hazards model is not ok.

```{r}
recurrence_obj = coxph(Surv(time, status) ~ rx, data = recurrence_data)
recurrence_fit = survfit(recurrence_obj, newdata = data.frame(rx= c("Obs", "Lev", "Lev+5FU")))
ggsurvplot(recurrence_fit, data = recurrence_data, fun = "cloglog", conf.int = FALSE, title = "Comparison of Survival Functions for Different Treatments", xlab = "Time until Recurrence of Colon Cancer (days)", ylab = "Survival Probability")

recurrence_gof_test = cox.zph(recurrence_obj, transform = "identity")

plot(recurrence_gof_test)
```
The survival curves are fairly parallel, so it's reasonable to assume that the Cox Proportional Hazards Assumption for the recurrence portion of the data is not violated by the treatment covariate.

The curvature of the function is not monotonically increasing as time increases, so the Schoenfeld residuals are not related to survival time. Therefore, the PH assumption does hold for the *rx* covariate.

AIC:

Now that the treatment covariate has been confirmed to not violate the Cox Proportional Hazards Assumption and the recurrence subset of colon cancer data has been cleaned, the next step is to find the model with the most significant covariates under the AIC criterion.


For the AIC tests, the covariates *study* and *id* are not included. The *id* covariate is the same as the observation number, it doesn't have contextual significance to the event of relapse or death from colon cancer. The *study* covariate is not included as all of the subjects are from the same study.

```{r}
# Level 1:
# Construct a list of covariates to put into the models:
recurrence_covariates = c("obstruct", "adhere", "nodes", "node4", "differ", "extent", "surg", "perfor", "sex", "age")

# building a model per covariate by pasting the given covariate into the formula

# the set_names function helps to clear up which AIC value corresponds to which model when performing the AIC function

recurrence_models = map(recurrence_covariates, \(v) coxph(as.formula(paste("Surv(time, status) ~ rx + ", v)), data = recurrence_data)) |> set_names(recurrence_covariates)

aic_lvl1 = map_dbl(recurrence_models, AIC) |>
  sort()

aic_lvl1

```
The model with the *node4* covariate, the binary variable for whether the patient had more than 4 positive lymph nodes, had the lowest AIC.

Since the *nodes* covariate and *node4* covariate are closely related, the *nodes* covariate will be skipped.

Therefore, forward selection proceeds with the above covariate.

```{r}
# Level 2:
# Construct a list of covariates to put into the models:
recurrence_covariates2 = c("obstruct", "adhere", "differ", "extent", "surg", "perfor", "sex", "age")

# Build a model per covariate by pasting the given covariate into the formula.

# The set_names function helps to clear up which AIC value corresponds to which model when performing the AIC function

recurrence_models2 = map(recurrence_covariates2, \(v) coxph(as.formula(paste("Surv(time, status) ~ rx + node4 + ", v)), data = recurrence_data)) |> set_names(recurrence_covariates2)

aic_lvl2 = map_dbl(recurrence_models2, AIC) |>
  sort()

aic_lvl2

```
The model with the *extent* covariate, the description of the local spread of the tumor, had the lowest AIC.

Therefore, forward selection proceeds with the above covariate.

```{r}
# Level 3:
# Construct a list of covariates to put into the models:
recurrence_covariates3 = c("obstruct", "adhere", "differ", "surg", "perfor", "sex", "age")

# building a model per covariate by pasting the given covariate into the formula

# the set_names function helps to clear up which AIC value corresponds to which model when performing the AIC function

recurrence_models3 = map(recurrence_covariates3, \(v) coxph(as.formula(paste("Surv(time, status) ~ rx + node4 + extent + ", v)), data = recurrence_data)) |> set_names(recurrence_covariates3)

aic_lvl3 = map_dbl(recurrence_models3, AIC) |>
  sort()

aic_lvl3

```

The model with the *surg* covariate, the time from initial surgery to registration in the study, had the lowest AIC.

Therefore, forward selection proceeds with the above covariate.

```{r}
# Level 4:
# list of covariates to put into the models
recurrence_covariates4 = c("obstruct", "adhere", "differ", "perfor", "sex", "age")

# building a model per covariate by pasting the given covariate into the formula

# the set_names function helps to clear up which AIC value corresponds to which model when performing the AIC function

recurrence_models4 = map(recurrence_covariates4, \(v) coxph(as.formula(paste("Surv(time, status) ~ rx + node4 + extent + surg + ", v)), data = recurrence_data)) |> set_names(recurrence_covariates4)

aic_lvl4 = map_dbl(recurrence_models4, AIC) |>
  sort()

aic_lvl4

```
The model with the *differ* covariate, the description of the removed cancer cells from the colon, had the lowest AIC.

Therefore, forward selection proceeds with the above covariate.

```{r}
# Level 5:
# list of covariates to put into the models
recurrence_covariates5 = c("adhere", "obstruct", "perfor", "sex", "age")

# building a model per covariate by pasting the given covariate into the formula

# the set_names function helps to clear up which AIC value corresponds to which model when performing the AIC function

recurrence_models5 = map(recurrence_covariates5, \(v) coxph(as.formula(paste("Surv(time, status) ~ rx + node4 + extent + surg + differ + ", v)), data = recurrence_data)) |> set_names(recurrence_covariates5)

aic_lvl5 = map_dbl(recurrence_models5, AIC) |>
  sort()

aic_lvl5

```

The model with the *obstruct* covariate, the binary variable for whether the cancer had adhered to other organs, had the lowest AIC.

Therefore, forward selection proceeds with the above covariate.

```{r}
# Level 6:
# list of covariates to put into the models
recurrence_covariates6 = c("adhere", "perfor", "sex", "age")

# building a model per covariate by pasting the given covariate into the formula

# the set_names function helps to clear up which AIC value corresponds to which model when performing the AIC function

recurrence_models6 = map(recurrence_covariates6, \(v) coxph(as.formula(paste("Surv(time, status) ~ rx + node4 + extent + surg + differ + obstruct + ", v)), data = recurrence_data)) |> set_names(recurrence_covariates6)

aic_lvl6 = map_dbl(recurrence_models6, AIC) |>
  sort()

aic_lvl6

```
None of the AICs shown above are less than the previous model, so the chosen model has the following covariates: *obstruct*, *surg*, *extent*, *node4*, and *differ*.

Next, the model was summarized in order to conclude relationships between the different levels of covariates, such as the treatment covariate and the differentiation covariate.
```{r}
summary(coxph(Surv(time, status) ~ rx + node4 + extent + surg + differ + obstruct, data = recurrence_data))
```

From the likelihood ratio test, the p-value is less than $2e-16$, which is much less than the critical value/significance level of $0.05$. 

The hazard rate for patients who took the treatment with just Levamisole is $1.163\%$ less hazardous than taking no treatment at all. Those who took Fluoracil in addition to Levamisole benefited with a hazard ratio of $0.6065$, $39.35\%$ less hazardous than no treatment at all.

Patients who had more than 4 positive lymph nodes had over double the hazard rate of those who didn't.

As the spread of the tumor developed from muscles to continguous structures, the hazard ratio to those who only had submucosa development increased to as high as $3.64$ times as likely to suffer a recurrence of colon cancer.

Patients with a long time from their initial surgery to registration in the study had a 25% greater hazard rate than those with a shorter time interval.

Patients whose removed cancer cells were "moderately differentiated" had a $3.24\%$ lower hazard rate than patients whose cancer cells were "well differentiated", while those with "poorly differentiated" cells had $31.25\%$ higher hazard rate compared to same base group.

Patients whose colons were obstructed by a tumor had a $23.39\%$ higher hazard rate compared to those who were obstruction-free.

With the following exceptions of the treatment level that included Fluoracil and Levamisole, the node level of patients who had more than 4 positive lymph nodes, and the long time interval level between initial surgery to registering for the study, all of the other covariates' levels had 95% confidence intervals which contained the baseline $1$. This suggests that the most significant levels of covariates in their effect on the hazard rate of the recurrence of colon cancer are Levamisole + Fluoracil as a treatment, over 4 positive lymph nodes, spread of cancer to the contiguous structures, and a long time between initial surgery to registration for the study is the best fit for the recurrence data.

# Counting Process Model:

The data is looking at the time between recurrences of colon cancer and death. As a result, it can't be treated as independent intervals like the gap model because there is a relationship between the recurrence of colon cancer and death from colon cancer. Thus, the counting process model is the best model to use.

Earlier in the report, the colon covariates *start* and *stop* were created. They are needed in order to separate the recurrence of colon cancer and death from colon cancer into new rows.

```{r}
# Builds the start and stop covariates for the subset of the colon cancer data where only the recurrences of cancer are noted. 
recurrence_data = recurrence_data %>% 
  mutate(start = 0,
         stop = time)
# Established the subset of the colon cancer data where only the deaths from colon cancer are noted

death_data = colon[colon$etype == 2,]

# Modifying the death subset to join the recurrence subset by id. The mutation is so the end time for the recurrence row for a given id/subject is the start time for the death row for the same id/subject. 

death_data = death_data %>% 
  left_join(recurrence_data %>% select(id, recurrence_time = time), by = "id") %>% 
  mutate(start = recurrence_time,
         stop = time)

# The two subsets are then combined by the id covariate from earlier. They are then arranged in order of id. The recurrence_time covariate, established in the joining process, is removed as it's just a helper variable. Finally, the start covariate is mutated in the case where the subject does not have a recurrence of colon cancer but passes away instead.

colon_counting = bind_rows(recurrence_data, death_data) %>% 
  arrange(id) %>% 
  select(-recurrence_time) %>% 
  mutate(start = if_else(start == stop, 0, start))

```


Now the colon dataset counts the time between the beginning to the first recurrence, the time between the recurrence to the next recurrence or death. 

Then we checked if the Cox Proportional Hazards assumption was violated or not in terms of the treatment covariate.

This is checked through a survival plot of the curves using the "cloglog" value for the fun parameter and a plot of the coxzph test.

If the p-value for the coxzph test for the treatment covariate is less than $0.05$, then the cox proportional hazards model is not ok.

```{r}
counting_obj = coxph(Surv(start, stop, status) ~ rx, data = colon_counting)
counting_fit = survfit(counting_obj, newdata = data.frame(rx= c("Obs", "Lev", "Lev+5FU")))
ggsurvplot(counting_fit, data = colon_counting, fun = "cloglog", conf.int = FALSE, title = "Comparison of Survival Functions for Different Treatments", xlab = "Time until Recurrence or Death from Colon Cancer (days)", ylab = "Survival Probability")

counting_gof_test = cox.zph(counting_obj, transform = "identity")

plot(counting_gof_test)
```
The curvature of the function is not monotonically increasing as time increases, so the Schoenfeld residuals are not related to survival time. Therefore, the PH assumption does hold for the *rx* covariate for the merged dataset.

Next, a cox proportional hazards model of this dataset will be constructed with the new time variables in the Survival object. Then, AIC + forward selection will find the most significant covariates for this model.

Similar to the AIC process for the marginal model for the recurrence data, the study covariate will not be included. However, the *id* covariate will be included, but as a cluster in order to compress multiple *id* rows that have the same *id* into one subject/*id*.

```{r}
# Level 1:
# list of covariates to put into the models
colon_covariates = c("obstruct", "adhere", "nodes", "node4", "differ", "extent", "surg", "perfor", "sex", "age")

# building a model per covariate by pasting the given covariate into the formula

# the set_names function helps to clear up which AIC value corresponds to which model when performing the AIC function

colon_models = map(colon_covariates, \(v) coxph(as.formula(paste("Surv(start, stop, status) ~ rx + cluster(id) + ", v)), data = colon_counting)) |> set_names(colon_covariates)

colon_aic_lvl1 = map_dbl(colon_models, AIC) |>
  sort()

colon_aic_lvl1

```

The model with the *node4* covariate, the binary variable for whether the patient had more than 4 positive lymph nodes, had the lowest AIC.

Since the *nodes* covariate and *node4* covariate are closely related, the *nodes* covariate will be skipped.

Therefore, forward selection proceeds with the above covariate.

```{r}
# Level 2:
# list of covariates to put into the models
colon_covariates2 = c("obstruct", "adhere", "differ", "extent", "surg", "perfor", "sex", "age")

# building a model per covariate by pasting the given covariate into the formula

# the set_names function helps to clear up which AIC value corresponds to which model when performing the AIC function

colon_models2 = map(colon_covariates2, \(v) coxph(as.formula(paste("Surv(start, stop, status) ~ rx + cluster(id) + node4 + ", v)), data = colon_counting)) |> set_names(colon_covariates2)

colon_aic_lvl2 = map_dbl(colon_models2, AIC) |>
  sort()

colon_aic_lvl2

```
The model with the *extent* covariate, the description of the local spread of the tumor, had the lowest AIC.

Therefore, forward selection proceeds with the above covariate.

```{r}
# Level 3:
# Construct a list of covariates to put into the models:
colon_covariates3 = c("obstruct", "adhere", "differ", "surg", "perfor", "sex", "age")

# Build a model per covariate by pasting the given covariate into the formula.

# The set_names function helps to clarify up which AIC value corresponds to which model when performing the AIC function.

colon_models3 = map(colon_covariates3, \(v) coxph(as.formula(paste("Surv(start, stop, status) ~ rx + cluster(id) + node4 + extent + ", v)), data = colon_counting)) |> set_names(colon_covariates3)

colon_aic_lvl3 = map_dbl(colon_models3, AIC) |>
  sort()

colon_aic_lvl3

```
The model with the *surg* covariate, the time from initial surgery to registration in the study, had the lowest AIC.

Therefore, forward selection proceeds with the above covariate.

```{r}
# Level 4:
# Construct a list of covariates to put into the models:
colon_covariates4 = c("obstruct", "adhere", "differ",  "perfor", "sex", "age")

# Build a model per covariate by pasting the given covariate into the formula.

# The set_names function helps to clarify up which AIC value corresponds to which model when performing the AIC function.

colon_models4 = map(colon_covariates4, \(v) coxph(as.formula(paste("Surv(start, stop, status) ~ rx + cluster(id) + node4 + extent + surg + ", v)), data = colon_counting)) |> set_names(colon_covariates4)

colon_aic_lvl4 = map_dbl(colon_models4, AIC) |>
  sort()

colon_aic_lvl4

```
The model with the *adhere* covariate, the binary variable of whether the cancer had adhered to other organs, had the lowest AIC.

Therefore, forward selection proceeds with the above covariate.

```{r}
# Level 5:
# Construct a list of covariates to put into the models:
colon_covariates5 = c("obstruct", "differ",  "perfor", "sex", "age")

# Build a model per covariate by pasting the given covariate into the formula.

# The set_names function helps to clarify up which AIC value corresponds to which model when performing the AIC function.

colon_models5 = map(colon_covariates5, \(v) coxph(as.formula(paste("Surv(start, stop, status) ~ rx + cluster(id) + node4 + extent + surg + adhere + ", v)), data = colon_counting)) |> set_names(colon_covariates5)

colon_aic_lvl5 = map_dbl(colon_models5, AIC) |>
  sort()

colon_aic_lvl5

```

The model with the *obstruct* covariate, the binary variable for whether the cancer had adhered to other organs, had the lowest AIC.

Therefore, forward selection proceeds with the above covariate.

```{r}
# Level 6:
# Construct a list of covariates to put into the models:
colon_covariates6 = c("differ",  "perfor", "sex", "age")

# Build a model per covariate by pasting the given covariate into the formula.

# The set_names function helps to clarify up which AIC value corresponds to which model when performing the AIC function.

colon_models6 = map(colon_covariates6, \(v) coxph(as.formula(paste("Surv(start, stop, status) ~ rx + cluster(id) + node4 + extent + surg + adhere + obstruct + ", v)), data = colon_counting)) |> set_names(colon_covariates6)

colon_aic_lvl6 = map_dbl(colon_models6, AIC) |>
  sort()

colon_aic_lvl6

```
The model with the *differ* covariate, the description of the removed cancer cells from the colon, had the lowest AIC.

Therefore, forward selection proceeds with the above covariate.

```{r}
# Level 7:
# Construct a list of covariates to put into the models:
colon_covariates7 = c("perfor", "sex", "age")

# Build a model per covariate by pasting the given covariate into the formula.

# The set_names function helps to clarify up which AIC value corresponds to which model when performing the AIC function.

colon_models7 = map(colon_covariates7, \(v) coxph(as.formula(paste("Surv(start, stop, status) ~ rx + cluster(id) + node4 + extent + surg + adhere + obstruct + differ + ", v)), data = colon_counting)) |> set_names(colon_covariates7)

colon_aic_lvl7 = map_dbl(colon_models7, AIC) |>
  sort()

colon_aic_lvl7

```

None of the models at this level have an AIC lower than the previous model, so the counting process model after AIC criterion has the following covariates, besides treatment and id: *node4*, *extent*, *surg*, *adhere*, *obstruct*, and *differ*


Next, the model was summarized in order to conclude relationships between the different levels of covariates, such as the treatment covariate and the differentiation covariate.

```{r}
summary(coxph(Surv(start, stop, status) ~ rx + cluster(id) + node4 + extent + surg + adhere + obstruct + differ, data = recurrence_data))
```

From the likelihood ratio test, the p-value is less than $2e-16$, which is much less than the critical value/significance level of $0.05$. 

The hazard rate for patients who took the treatment with just Levamisole is $2.208\%$ less hazardous than taking no treatment at all. Those who took Fluoracil in addition to Levamisole benefited with a hazard ratio of $0.6062$, $39.38\%$ less hazardous than no treatment at all.

Patients who had more than 4 positive lymph nodes had over double the hazard rate of those who didn't.

As the spread of the tumor developed from muscles to contiguous structures, the hazard ratio to those who only had submucosa development increased to as high as $3.3764$ times as likely to suffer a recurrence of colon cancer.

Patients with a long time from their initial surgery to registration in the study had a 25% greater hazard rate than those with a shorter time interval.

Patients whose removed cancer cells were "moderately differentiated" had a $3.86\%$ lower hazard rate than patients whose cancer cells were "well differentiated", while those with "poorly differentiated" cells had $28.41\%$ higher hazard rate compared to same base group.

Patients whose colons were obstructed by a tumor had a $23.37\%$ higher hazard rate compared to those who were obstruction-free.

With the following exceptions of the treatment level that included Fluoracil and Levamisole, the node level of patients who had more than 4 positive lymph nodes, and the long time interval level between initial surgery to registering for the study, all of the other covariates' levels had 95% confidence intervals which contained the baseline $1$. This suggests that the most significant levels of covariates in their effect on the hazard rate of either recurrence or death from colon cancer are Levamisole + Fluoracil as a treatment, over 4 positive lymph nodes, spread of cancer to the contiguous structures, and a long time between initial surgery to registration for the study is the best fit for the data as a whole.